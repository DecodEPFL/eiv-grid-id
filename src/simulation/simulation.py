from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Tuple

import numpy as np
import pandapower as pp
import pandas as pd
from pandapower.timeseries import OutputWriter, run_timeseries
from tqdm import tqdm

from conf.conf import SIM_DIR


"""
    Implementation of the PandaPower simulation tool, to generate voltages and currents from network and loads.

    Copyright @donelef, @jbrouill on GitHub
"""


@dataclass
class SimulationResult(object):
    """
    Data class to store voltages, loads and loading percentage of the grid.
    This is generated by the PandaPower simulation and can be read/written to files.
    """
    vm_pu: pd.DataFrame
    va_degree: pd.DataFrame
    p_mw: pd.DataFrame
    q_mvar: pd.DataFrame
    loading_percent: pd.DataFrame
    result_path: Path

    @staticmethod
    def from_dir(dir_path: Path):
        return SimulationResult(
            result_path=dir_path,
            **{f.stem: pd.read_csv(f, sep=";", index_col=0) for f in dir_path.rglob("*.csv")}
        )


def run_simulation(controlled_net: pp.pandapowerNet, output_path: Path = SIM_DIR,
                   verbose: bool = True, **kwargs) -> SimulationResult:
    """
    Runs the simulation of a PandaPower network to obtain grid voltages based on loads.
    It saves the results in a file as well.

    :param controlled_net: PandaPower network to simulate
    :param output_path: path of the file to generate with the data
    :param verbose: verbose on/off
    :param kwargs: additional arguments for PandaPower
    :return: SimulationResult object with the generated data
    """
    # Create file path and writer
    timed_out_path = output_path / f"sim_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    ow = OutputWriter(controlled_net, output_path=timed_out_path, output_file_type=".csv")

    # Define variables to save
    ow.log_variable("res_line", "loading_percent")
    for v in ["vm_pu", "va_degree", "p_mw", "q_mvar"]:
        ow.log_variable("res_bus", v)

    # Run network simulation
    run_timeseries(controlled_net, verbose=verbose, numba=False, **kwargs)

    return SimulationResult.from_dir(timed_out_path)


@dataclass
class SimulationResult3P(object):
    """
    Data class to store voltages, loads and loading percentage of the grid.
    This is generated by the PandaPower simulation and can be read/written to files.
    """
    vm_a_pu: pd.DataFrame
    va_a_degree: pd.DataFrame
    p_a_mw: pd.DataFrame
    q_a_mvar: pd.DataFrame
    vm_b_pu: pd.DataFrame
    va_b_degree: pd.DataFrame
    p_b_mw: pd.DataFrame
    q_b_mvar: pd.DataFrame
    vm_c_pu: pd.DataFrame
    va_c_degree: pd.DataFrame
    p_c_mw: pd.DataFrame
    q_c_mvar: pd.DataFrame
    result_path: Path

    @staticmethod
    def from_dir(dir_path: Path):
        return SimulationResult3P(
            result_path=dir_path,
            **{f.stem: pd.read_csv(f, sep=";", index_col=0) for f in dir_path.rglob("*.csv")}
        )


def run_simulation_3ph(controlled_net: pp.pandapowerNet, output_path: Path = SIM_DIR,
                       verbose: bool = True, **kwargs) -> SimulationResult3P:
    """
    Runs the simulation of a PandaPower network to obtain grid voltages based on loads.
    It saves the results in a file as well.

    :param controlled_net: PandaPower network to simulate
    :param output_path: path of the file to generate with the data
    :param verbose: verbose on/off
    :param kwargs: additional arguments for PandaPower
    :return: SimulationResult object with the generated data
    """

    # Create file path and writer
    timed_out_path = output_path / f"sim_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    ow = OutputWriter(controlled_net, output_path=timed_out_path, output_file_type=".csv", log_variables=[])

    # Define variables to save
    #ow.log_variable("res_line", "loading_percent")
    for v in ["vm_a_pu", "va_a_degree", "p_a_mw", "q_a_mvar",
              "vm_b_pu", "va_b_degree", "p_b_mw", "q_b_mvar",
              "vm_c_pu", "va_c_degree", "p_c_mw", "q_c_mvar"]:
        ow.log_variable("res_bus_3ph", v, controlled_net.bus.index)

    if "run" not in kwargs.keys():
        kwargs = {**kwargs, "run": pp.runpp_3ph}
    if "voltage_depend_loads" not in kwargs.keys(): # doesn't work
        kwargs = {**kwargs, "voltage_depend_loads": True}

    # Run network simulation
    run_timeseries(controlled_net, verbose=verbose, numba=False, **kwargs)

    return SimulationResult3P.from_dir(timed_out_path)


def get_current_and_voltage(sim_result, y_bus: np.array) -> Tuple[np.array, np.array]:
    """
    Extracts the results of a simulation into usable matrices of voltages and currents.

    :param sim_result: results of a simulation
    :param y_bus: admittance matrix of the network
    :return: tuple of two T-by-n numpy arrays of voltages and currents respectively
    """
    if type(sim_result) is SimulationResult:
        va_rad = sim_result.va_degree.values * np.pi / 180
        voltage = sim_result.vm_pu.values * (np.cos(va_rad) + 1j * np.sin(va_rad))
        current = voltage @ y_bus
        return voltage, current
    elif type(sim_result) is SimulationResult3P:
        va_a_rad = sim_result.va_a_degree.values * np.pi / 180
        va_b_rad = sim_result.va_b_degree.values * np.pi / 180
        va_c_rad = sim_result.va_c_degree.values * np.pi / 180
        voltage_a = sim_result.vm_a_pu.values * (np.cos(va_a_rad) + 1j * np.sin(va_a_rad))
        voltage_b = sim_result.vm_b_pu.values * (np.cos(va_b_rad) + 1j * np.sin(va_b_rad))
        voltage_c = sim_result.vm_c_pu.values * (np.cos(va_c_rad) + 1j * np.sin(va_c_rad))
        voltage = np.kron(voltage_a, np.array([1, 0, 0])) + np.kron(voltage_b, np.array([0, 1, 0])) \
            + np.kron(voltage_c, np.array([0, 0, 1]))

        current = voltage @ y_bus
        return voltage, current

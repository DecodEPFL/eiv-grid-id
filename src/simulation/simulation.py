from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Tuple

import numpy as np
import pandapower as pp
import pandas as pd
from pandapower.control import ConstControl
from pandapower.timeseries import DFData, OutputWriter, run_timeseries
from tqdm import tqdm

from conf.conf import SIM_DIR

from src.simulation.network import NetData


"""
    Implementation of the PandaPower simulation tool, to generate voltages and currents from network and loads.

    Copyright @donelef, @jbrouill on GitHub
"""

@dataclass
class SimulationResult(object):
    """
    Data class to store voltages, loads and loading percentage of the grid.
    This is generated by the PandaPower simulation and can be read/written to files.
    """
    vm_pu: pd.DataFrame
    va_degree: pd.DataFrame
    p_mw: pd.DataFrame
    q_mvar: pd.DataFrame
    loading_percent: pd.DataFrame
    result_path: Path

    @staticmethod
    def from_dir(dir_path: Path):
        return SimulationResult(
            result_path=dir_path,
            **{f.stem: pd.read_csv(f, sep=";", index_col=0) for f in dir_path.rglob("*.csv")}
        )


class SimulatedNet(NetData):

    def __init__(self, ns: list = None, ls: list = None, other=None):
        NetData.__init__(self, ns, ls, other)

        self.sim_result = None

    def run(self, load_p: np.array, load_q: np.array, output_path: Path = SIM_DIR,
            verbose: bool = True, **kwargs):
        """
        Runs the simulation of a PandaPower network to obtain grid voltages based on loads.
        It saves the results in a file as well.

        :param load_p: T-by-n array of active loads as numpy array
        :param load_q: T-by-n array of reactive loads as numpy array
        :param output_path: path of the file to generate with the data
        :param verbose: verbose on/off
        :param kwargs: additional arguments for PandaPower
        :return: SimulationResult object with the generated data
        """
        variables = ['p_a_mw', 'p_b_mw', 'p_c_mw', 'q_a_mvar', 'q_b_mvar', 'q_c_mvar']
        controlled_net = self.deepcopy()

        load_df = DFData(pd.DataFrame(load_p, columns=self.load.index))
        ConstControl(controlled_net, element='load', element_index=self.load.index,
                     variable='p_mw', data_source=load_df, profile_name=self.load.index)
        load_df = DFData(pd.DataFrame(load_q, columns=self.load.index))
        ConstControl(controlled_net, element='load', element_index=self.load.index,
                     variable='q_mvar', data_source=load_df, profile_name=self.load.index)

        # Create file path and writer
        timed_out_path = output_path / f"sim_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        ow = OutputWriter(controlled_net, output_path=timed_out_path, output_file_type=".csv")

        # Define variables to save
        ow.log_variable("res_line", "loading_percent")
        for v in ["vm_pu", "va_degree", "p_mw", "q_mvar"]:
            ow.log_variable("res_bus", v)

        # Run network simulation
        run_timeseries(controlled_net, verbose=verbose, numba=False, **kwargs)

        self.sim_result = SimulationResult.from_dir(timed_out_path)
        return self

    def get_current_and_voltage(self) -> Tuple[np.array, np.array]:
        """
        Extracts the results of a simulation into usable matrices of voltages and currents.

        :param sim_result: results of a simulation
        :param y_bus: admittance matrix of the network
        :return: tuple of two T-by-n numpy arrays of voltages and currents respectively
        """
        if self.sim_result is None:
            return None, None

        va_rad = self.sim_result.va_degree.values * np.pi / 180
        voltage = self.sim_result.vm_pu.values * (np.cos(va_rad) + 1j * np.sin(va_rad))
        current = voltage @ self.make_y_bus()
        return voltage, current

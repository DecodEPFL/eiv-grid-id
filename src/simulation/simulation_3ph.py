from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Tuple

import numpy as np
import pandapower as pp
import pandas as pd
from pandapower.control import ConstControl
from pandapower.timeseries import DFData, OutputWriter, run_timeseries
from tqdm import tqdm

from conf.conf import SIM_DIR

from src.simulation.network_3ph import NetData3P


"""
    Implementation of the PandaPower simulation tool, to generate voltages and currents from network and loads.

    Copyright @donelef, @jbrouill on GitHub
"""


@dataclass
class SimulationResult3P(object):
    """
    Data class to store voltages, loads and loading percentage of the grid.
    This is generated by the PandaPower simulation and can be read/written to files.
    """
    vm_a_pu: pd.DataFrame
    va_a_degree: pd.DataFrame
    p_a_mw: pd.DataFrame
    q_a_mvar: pd.DataFrame
    vm_b_pu: pd.DataFrame
    va_b_degree: pd.DataFrame
    p_b_mw: pd.DataFrame
    q_b_mvar: pd.DataFrame
    vm_c_pu: pd.DataFrame
    va_c_degree: pd.DataFrame
    p_c_mw: pd.DataFrame
    q_c_mvar: pd.DataFrame
    result_path: Path

    @staticmethod
    def from_dir(dir_path: Path):
        return SimulationResult3P(
            result_path=dir_path,
            **{f.stem: pd.read_csv(f, sep=";", index_col=0) for f in dir_path.rglob("*.csv")}
        )


class SimulatedNet3P(NetData3P):

    def __init__(self, ts: dict, ns: list = [], ls: list = [], other=pp.create_empty_network("net")):
        NetData3P.__init__(self, ts, ns, ls, other)

        self.sim_result = None

    def run(self, load_p: np.array, load_q: np.array, asym_load: np.array = None,
            output_path: Path = SIM_DIR, verbose: bool = True, **kwargs):
        """
        Runs the simulation of a PandaPower network to obtain grid voltages based on loads.
        It saves the results in a file as well.

        :param controlled_net: PandaPower network to simulate
        :param output_path: path of the file to generate with the data
        :param verbose: verbose on/off
        :param kwargs: additional arguments for PandaPower
        :return: SimulationResult object with the generated data
        """
        variables = ['p_a_mw', 'p_b_mw', 'p_c_mw', 'q_a_mvar', 'q_b_mvar', 'q_c_mvar']
        controlled_net = self.deepcopy()

        load_df = DFData(pd.DataFrame(load_p, columns=self.load.index))
        ConstControl(controlled_net, element='load', element_index=self.load.index,
                     variable='p_mw', data_source=load_df, profile_name=self.load.index)
        load_df = DFData(pd.DataFrame(load_q, columns=self.load.index))
        ConstControl(controlled_net, element='load', element_index=self.load.index,
                     variable='q_mvar', data_source=load_df, profile_name=self.load.index)

        if asym_load is not None:
            for i in range(len(variables)):
                load_df = DFData(pd.DataFrame(asym_load[i], columns=self.asymmetric_load.index))
                ConstControl(controlled_net, element='asymmetric_load', element_index=self.asymmetric_load.index,
                             variable=variables[i], data_source=load_df, profile_name=self.asymmetric_load.index)

        # Create file path and writer
        timed_out_path = output_path / f"sim_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        ow = OutputWriter(controlled_net, output_path=timed_out_path, output_file_type=".csv", log_variables=[])

        # Define variables to save
        #ow.log_variable("res_line", "loading_percent")
        for v in ["vm_a_pu", "va_a_degree", "p_a_mw", "q_a_mvar",
                  "vm_b_pu", "va_b_degree", "p_b_mw", "q_b_mvar",
                  "vm_c_pu", "va_c_degree", "p_c_mw", "q_c_mvar"]:
            ow.log_variable("res_bus_3ph", v, controlled_net.bus.index)

        if "run" not in kwargs.keys():
            kwargs = {**kwargs, "run": pp.runpp_3ph}
        if "voltage_depend_loads" not in kwargs.keys(): # doesn't work
            kwargs = {**kwargs, "voltage_depend_loads": True}

        # Run network simulation
        run_timeseries(controlled_net, verbose=verbose, numba=False, **kwargs)

        self.sim_result = SimulationResult3P.from_dir(timed_out_path)
        return self

    def get_current_and_voltage(self) -> Tuple[np.array, np.array]:
        """
        Extracts the results of a simulation into usable matrices of voltages and currents.

        :param sim_result: results of a simulation
        :param y_bus: admittance matrix of the network
        :return: tuple of two T-by-n numpy arrays of voltages and currents respectively
        """
        if self.sim_result is None:
            return None, None

        va_a_rad = self.sim_result.va_a_degree.values * np.pi / 180
        va_b_rad = self.sim_result.va_b_degree.values * np.pi / 180
        va_c_rad = self.sim_result.va_c_degree.values * np.pi / 180
        voltage_a = self.sim_result.vm_a_pu.values * (np.cos(va_a_rad) + 1j * np.sin(va_a_rad))
        voltage_b = self.sim_result.vm_b_pu.values * (np.cos(va_b_rad) + 1j * np.sin(va_b_rad))
        voltage_c = self.sim_result.vm_c_pu.values * (np.cos(va_c_rad) + 1j * np.sin(va_c_rad))
        voltage = np.kron(voltage_a, np.array([1, 0, 0])) + np.kron(voltage_b, np.array([0, 1, 0])) \
            + np.kron(voltage_c, np.array([0, 0, 1]))

        current = voltage @ self.make_y_bus()
        return voltage, current
